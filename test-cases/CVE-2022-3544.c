#include "CVE-2022-3544.h"

void main()
{
    struct damon_sysfs_target *st;
    struct damon_ctx *ctx;
    damon_sysfs_add_target_does_error(st, ctx);
    damon_sysfs_add_target_does_not_error(st, ctx);
}

static int
damon_sysfs_add_target_does_error(struct damon_sysfs_target *sys_target,
                                  struct damon_ctx *ctx)
{
    struct damon_target *t = damon_new_target();
    int err = -EINVAL;

    if (!t)
        return -ENOMEM;
    // here add damon_add_target(ctx, t);
    if (damon_target_has_pid(ctx)) {
        t->pid = find_get_pid(sys_target->pid);
        if (!t->pid)
            goto destroy_targets_out;
    }
    damon_add_target(ctx, t); // remove this
    err = damon_sysfs_set_regions(t, sys_target->regions);
    if (err)
        goto destroy_targets_out;
    return 0;

destroy_targets_out:
    damon_sysfs_destroy_targets(ctx);
    return err;
}

static int
damon_sysfs_add_target_does_not_error(struct damon_sysfs_target *sys_target,
                                      struct damon_ctx *ctx)
{
    struct damon_target *t = damon_new_target();
    int err = -EINVAL;

    if (!t)
        return -ENOMEM;
    damon_add_target(ctx, t);
    if (damon_target_has_pid(ctx)) {
        t->pid = find_get_pid(sys_target->pid);
        if (!t->pid)
            goto destroy_targets_out;
    }
    err = damon_sysfs_set_regions(t, sys_target->regions);
    if (err)
        goto destroy_targets_out;
    return 0;

destroy_targets_out:
    damon_sysfs_destroy_targets(ctx);
    return err;
}

static void damon_sysfs_destroy_targets(struct damon_ctx *ctx)
{
    struct damon_target *t, *next;
    bool has_pid = damon_target_has_pid(ctx);

    damon_for_each_target_safe(t, next, ctx);
    {
        if (has_pid)
            put_pid(t->pid);
        damon_destroy_target(t);
    }
}

void damon_destroy_target(struct damon_target *t)
{
    damon_del_target(t);
    damon_free_target(t);
}

static void damon_del_target(struct damon_target *t)
{
    list_del(&t->list);
}

void damon_free_target(struct damon_target *t)   // deallocation site?
{
    struct damon_region *r, *next;

    damon_for_each_region_safe(r, next, t);
    damon_free_region(r);
    kfree(t);
}

void *kmalloc(size_t size, gfp_t gfp)
{
    void *ret;

    ret = malloc(size);

    return ret;
}

void kfree(void *p)
{
    if (!p)
        return;

    free(p);
}

int damon_target_has_pid(struct damon_ctx *ctx)
{
    return 0;
}

static int damon_sysfs_set_regions(struct damon_target *t,
                                   struct damon_sysfs_regions *sysfs_regions)
{
    return 0;
}

int list_add_tail(struct list_head *a, struct list_head *b)
{
    return 0;
}

int damon_for_each_region_safe(struct damon_region *a, struct damon_region *b,
                               struct damon_target *c)
{
    return 0;
}

int damon_free_region(struct damon_region *x)
{
    return 0;
}

int list_del(struct list_head *)
{
    return 0;
}

int put_pid(struct pid *)
{
    return 0;
}

void damon_add_target(
    struct damon_ctx *ctx,
    struct damon_target *t)   // found in mm/damon/core.c (mm = memory management)
{
    list_add_tail(&t->list, &ctx->adaptive_targets);
}

/** found in list.h header file (linux/scripts/mod/list.h)
 * INIT_LIST_HEAD - Initialize a list_head structure
 * @list: list_head structure to be initialized.
 *
 * Initializes the list_head to point to itself.  If it is a list header,
 * the result is an empty list.
 */
static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list->next = list;
    list->prev = list;
}

void damon_for_each_target_safe(struct damon_target *t,
                                struct damon_target *next,
                                struct damon_ctx *ctx)
{
    int x = 0;
};
